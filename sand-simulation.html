<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>WebGL Demo</title>
    <style>
        *
        {
            font-family:Verdana, Geneva, Tahoma, sans-serif; 
            font-size: 20px;
            font-weight: bold;
        }
        body
        {
            background-color: blue;
        }
        button
        {
            width:120px;
            margin: 6px;
            padding: 6px;
            border: 2px solid black;
            border-radius: 8px;
            background-color: #8899AA;
        }

        .font-bw
        {
            color: black;
            text-shadow: 0px 0px 1px white,
                0px 0px 2px white,
                0px 0px 3px white,
                0px 0px 4px white,
                0px 0px 5px white,
                0px 0px 6px white,
                0px 0px 7px white,
                0px 0px 8px white;
        }
        .font-wb
        {
            color: white;
            text-shadow: 0px 0px 1px black,
                0px 0px 2px black,
                0px 0px 3px black,
                0px 0px 4px black,
                0px 0px 5px black,
                0px 0px 6px black,
                0px 0px 7px black,
                0px 0px 8px black;
        }
        td
        {
            text-align: center;
            border: 1px solid black;
        }

    </style>
</head>

<body>
<table>
    <tr>
        <td><canvas id="glcanvas" width="512" height="512"></canvas></td>
        <td>
            <u>Elements</u> <br>
            <button id="vaporButton" class="font-bw" style="background-color: rgb(200, 200, 200);">Vapor</button> <br>
            <button id="airButton"   class="font-bw" style="background-color: rgb( 20,  20,  20);">Air</button> <br>
            <button id="fireButton"  class="font-bw" style="background-color: rgb(235,  20,  20);">Fire</button> <br>
            <button id="oilButton"   class="font-bw" style="background-color: rgb(200,  20, 235);">Oil</button> <br>
            <button id="waterButton" class="font-bw" style="background-color: rgb(20, 20, 235);">Water</button> <br>
            <button id="lavaButton"  class="font-bw" style="background-color: rgb(235, 128,  20);">Lava</button> <br>
            <button id="plantButton" class="font-bw" style="background-color: rgb( 20, 180,  20);">Plant</button> <br>
            <button id="mudButton"   class="font-bw" style="background-color: rgb(150,  90,  30);">Mud</button> <br>
            <button id="iceButton"   class="font-bw" style="background-color: rgb(100, 200, 235);">Ice</button> <br>
            <button id="sandButton"  class="font-bw" style="background-color: rgb(235, 235,  20);">Sand</button> <br>
            <button id="rockButton"  class="font-bw" style="background-color: rgb(150, 150, 150);">Rock</button> <br>
            <button id="wallButton"  class="font-bw" style="background-color: rgb(100, 100, 100);">Wall</button> <br>
            <button id="virusButton" class="font-bw" style="background-color: rgb(235, 180, 180);">Virus</button> <br>
            <button id="cloneButton" class="font-bw" style="background-color: rgb(150, 235, 150);">Clone</button> <br>
            <button id="holeButton"  class="font-bw" style="background-color: rgb( 50,  50,  50);">Hole</button>
        </td>
        <td>
            <button id="pauseButton" class="font-wb">Pause</button> <br>
            <button id="slowestButton" class="font-wb">Slow</button> <br>
            <button id="slowButton" class="font-wb">Moderate</button> <br>
            <button id="normalButton" class="font-wb">Normal</button> <br>
            <button id="fastButton" class="font-wb">Fast</button>
        </td>
    </tr>
</table>
</body>

<script>

var canvas, gl, world,
worldWidth = textureWidth = 100,  
worldHeight = textureHeight = 100, 
canvasWidth = 800, canvasHeight = 800,
pixelData, texture, shaderProgram,
currentTime, previousTime, deltaTime, elapsedTime, tick = 0, fpsTimer = 0, fpsTicker = 0; 



// TODO: use setInterval instead?
var loopSpeed = 16, timeoutID = null; // need ID to stop current setTimeout

// TODO: fix pause mechanic
document.getElementById("pauseButton"  ).addEventListener("click", () => { loopSpeed = 1000; } ); // 1 FPD: Frame Per Day :)
document.getElementById("slowestButton").addEventListener("click", () => { loopSpeed = 1000; } );
document.getElementById("slowButton"   ).addEventListener("click", () => { loopSpeed = 100; } );
document.getElementById("normalButton" ).addEventListener("click", () => { loopSpeed = 16;  } );
document.getElementById("fastButton"   ).addEventListener("click", () => { loopSpeed = 4; } );

/**
 *   Each point in the world is represented by a number;
 *     int = data structure via bits 
 * 
 *  14 bit int: SLGRIMVVVVTTTT
 * 
 *  TODO: A SLG FAM VVVVVVVV RRRR TTTT
 * 
 *  TTTT: type (e.g. ), 0-15, also used for base color, also used for relative density (some particles fall through others)
 *  VVVV: random value, 0-10, used for RGB color variation
 *  R: Rigid,  true/false (1/0), affected by gravity?
 *  A: Active, true/false (1/0), can interact with other particles? (must have existed for at least one tick)
 *  M: Moved,  true/false (1/0), did the particle move during this cycle? (particles only move once) 
 *  S: Solid,  true/false (1/0), is Solid? (is only displaced in L/R direction, by heavier particles (other solids))
 *  L: Liquid, true/false (1/0), is Liquid? (can be displaced in any direction, by heavier particles. can flow L/R through liquids/gases)
 *  G: Gas,    true/false (1/0), is Gas? (can be displaced in any direction, by heavier particles. can flow L/R through gases)
 *  [[ additional bits could be specified later to store more properties or data ]]
 *  
 */

const TYPE_BITS   = [0,1,2,3], 
      RANDOM_BITS = [4,5,6,7],
      VALUE_BITS  = [8,9,10,11,12,13,14,15],
      RIGID_BIT = 16, ACTIVE_BIT = 17, MOVED_BIT = 18,
      SOLID_BIT = 19, LIQUID_BIT = 20,   GAS_BIT = 21,
      ANIMATE_BIT = 22;
      
      // RIGID -> rename to GRAVITY_BIT? or FALL_BIT?
      // ANIMATE_BIT: 22

const VAPOR =  0,   AIR =  1,  FIRE =  2,   
        OIL =  3, WATER =  4,  LAVA =  5,    MUD =  6,
      PLANT =  7,   ICE =  8,  SAND =  9,   ROCK = 10, 
       WALL = 11, VIRUS = 12, CLONE = 13, MUTATE = 14, HOLE = 15;

var selectedType = ROCK, borderType = WALL;

var gasTypes = [VAPOR, AIR];
var liquidTypes = [OIL, WATER, LAVA];
var solidTypes = [PLANT, MUD, ICE, SAND, ROCK, FIRE]; 
// FIRE is included in list of solids so that it doesn't flow sideways like liquid/gas
// FIRE has low index because "heat rises"

// the particle types that can change other particle types
// (also technically AIR, but this is included by the types below, 
//  and checking all neighbors of every AIR each tick would take a lot of time)
var transmuteTypes = [FIRE, LAVA, WATER, ICE, PLANT, MUD, VAPOR];
// reusable variables
var particleType, neighborType;
// used when checking all neighbors of a particle (possible particle-particle interactions)
var offsets = [ [-1,-1], [0,-1], [1,-1], [1,0], [1,1], [0,1], [-1,1], [-1,0] ];

document.getElementById("vaporButton").addEventListener("click", () => { selectedType = VAPOR } );
document.getElementById("airButton").addEventListener("click", () => { selectedType = AIR } );
document.getElementById("fireButton").addEventListener("click", () => { selectedType = FIRE } );
document.getElementById("oilButton").addEventListener("click", () => { selectedType = OIL } );
document.getElementById("waterButton").addEventListener("click", () => { selectedType = WATER } );
document.getElementById("lavaButton").addEventListener("click", () => { selectedType = LAVA } );
document.getElementById("plantButton").addEventListener("click", () => { selectedType = PLANT } );
document.getElementById("mudButton").addEventListener("click", () => { selectedType = MUD } );
document.getElementById("iceButton").addEventListener("click", () => { selectedType = ICE } );
document.getElementById("sandButton").addEventListener("click", () => { selectedType = SAND } );
document.getElementById("rockButton").addEventListener("click", () => { selectedType = ROCK } );
document.getElementById("wallButton").addEventListener("click", () => { selectedType = WALL } );
document.getElementById("virusButton").addEventListener("click", () => { selectedType = VIRUS } );
document.getElementById("cloneButton").addEventListener("click", () => { selectedType = CLONE } );
document.getElementById("holeButton").addEventListener("click", () => { selectedType = HOLE } );

var colorArray = [];
colorArray[VAPOR] = [200, 200, 200, 255]; // white
colorArray[AIR]   = [ 20,  20,  20, 255]; // black // no randomness
colorArray[FIRE]  = [235,  40,  40, 255]; // red
colorArray[OIL]   = [200,  20, 235, 255]; // purple
colorArray[WATER] = [ 20,  20, 235, 255]; // dark blue
colorArray[LAVA]  = [235, 128,  20, 255]; // orange
colorArray[PLANT] = [ 20, 180,  20, 255]; // dark green
colorArray[MUD]   = [150,  90,  30, 255]; // brown
colorArray[ICE]   = [100, 200, 235, 255]; // light blue
colorArray[SAND]  = [235, 235,  20, 255]; // yellow
colorArray[ROCK]  = [150, 150, 150, 255]; // light gray
colorArray[WALL]  = [100, 100, 100, 255]; // gray // no randomness // TODO: tan sparkle
colorArray[VIRUS] = [235, 180, 180, 255]; // pink, animated
colorArray[CLONE] = [150, 235, 150, 255]; // light green, animated
colorArray[HOLE]  = [ 50,  50,  50, 255]; // dark gray, animated

// for particle at position (x,y), change bit at index N to 1
function setBit( x,y, N ) { world[y][x] = world[y][x] | (1 << N); }

// for particle at position (x,y), change bit at index N to 0
function clearBit( x,y, N ) { world[y][x] = world[y][x] & (~(1 << N)); }

// for particle at position (x,y), get bit at index N
// since Javascript is "truthy", can interpret these as boolean values
function getBit( x,y, N ) { return (world[y][x] & (1 << N)) >> N; }

// check states
function isRigid( x,y )  { return getBit(x,y, RIGID_BIT); }
function isActive( x,y ) { return getBit(x,y, ACTIVE_BIT); }
function isMoved( x,y )  { return getBit(x,y, MOVED_BIT); }
function isSolid( x,y )  { return getBit(x,y, SOLID_BIT); }
function isLiquid( x,y ) { return getBit(x,y, LIQUID_BIT); }
function isGas( x,y )    { return getBit(x,y, GAS_BIT); }

// state = true
function setRigid( x,y )  { setBit(x,y, RIGID_BIT); }
function setActive( x,y ) { setBit(x,y, ACTIVE_BIT); }
function setMoved( x,y )  { setBit(x,y, MOVED_BIT); }
function setSolid( x,y )  { setBit(x,y, SOLID_BIT); }
function setLiquid( x,y ) { setBit(x,y, LIQUID_BIT); }
function setGas( x,y )    { setBit(x,y, GAS_BIT); }

// state = false
function clearRigid( x,y )  { clearBit(x,y, RIGID_BIT); }
function clearActive( x,y ) { clearBit(x,y, ACTIVE_BIT); }
function clearMoved( x,y )  { clearBit(x,y, MOVED_BIT); }

// reset particle
function clearAll( x,y ) { world[y][x] = 0; }

// set type bits to a given value
function setType( x,y, t ) { world[y][x] = (world[y][x] & ~(0b1111 << 0)) | (t << 0); }
function getType( x,y )    { return world[y][x] & 0b1111; }

// set random bits to a given number, 0 <= r <= 10
function clearRandom( x,y )  { world[y][x] = world[y][x] & ~(0b1111 << 4); }
function setRandom( x,y, r ) { world[y][x] = (world[y][x] & ~(0b1111 << 4)) | (r << 4); }
function getRandom( x,y )    { return (world[y][x] & (0b1111 << 4)) >> 4; }
function addRandom( x,y, v ) { setRandom( x,y, (getRandom(x,y)+v+11)%11 ); } // wraparound desired for shimmer animation

// set value bits to a given number, 0 <= r <= 255
function clearValue( x,y )  { world[y][x] = world[y][x] & ~(0b11111111 << 8); }
function setValue( x,y, r ) { world[y][x] = (world[y][x] & ~(0b11111111 << 8)) | (r << 8); }
function getValue( x,y )    { return (world[y][x] & (0b11111111 << 8)) >> 8; }
function addValue( x,y, v ) { setValue( x,y, getValue(x,y)+v ); } // careful to avoid wraparound...

// set all particle properties based on type
function setParticleFromType( x,y, t )
{
    clearAll(x,y);
    setType(x,y, t);
    
    // everything except WALL/AIR has random coloring
    if (t != WALL && t != AIR)
        setRandom( x,y, Math.floor(10 * Math.random()) );

    if ( gasTypes.includes(t) ) // FIRE?
        setGas(x,y);
    else if ( liquidTypes.includes(t) )
        setLiquid(x,y);
    else // if ( solidTypes.includes(t) ) 
        setSolid(x,y);

    // things that will never move
    if (t == PLANT || t == WALL || t == HOLE || t == VIRUS || t == CLONE)
        setRigid(x,y);

    // special values
    if (t == FIRE)
        setValue(x,y, 255);

    // ACTIVE is always set (to true) at beginning of particle processing
    //   does not apply to particles just transformed from interactions
    clearActive(x,y);
    // MOVED may be set during particle processing
    clearMoved(x,y);
}

function setParticleFromValue(x,y, v) { world[y][x] = v; }
function getParticle(x,y) { return world[y][x]; }

// check if coordinates are within world range
function isValid(x,y) { return (0 <= x) && (x < worldWidth) && (0 <= y) && (y < worldHeight); }

function couldMove(x,y) { return !isMoved(x,y) && !isRigid(x,y); }

function initializeWorld()
{
    // remember! y-by-x = rows-by-columns = height-by-width
    world = [];
    for (let y = 0; y < worldHeight; y++)
        world.push( new Array(worldWidth).fill(0) );

    for (let y = 0; y < worldHeight; y++)
        for (let x = 0; x < worldWidth; x++)
            setParticleFromType(x,y, AIR);

    setParticleFromType(4,2, SAND);
    setParticleFromType(4,3, SAND);
    setParticleFromType(4,4, SAND);
    setParticleFromType(4,5, SAND);
    
    // set borders on all sides (either WALL or HOLE), avoids out-of-bounds array index errors
    for (let x = 0; x < worldWidth; x++)
    {
        setParticleFromType(x, 0, borderType);
        setParticleFromType(x, worldHeight-1, borderType);
    }
    for (let y = 0; y < worldHeight; y++)
    {
        setParticleFromType(0, y, borderType);
        setParticleFromType(worldWidth-1, y, borderType);
    }
}

// avoid unusual behaviors arising from left-to-right processing
//   by processing coordinates in a random order.
//   does *not* include border cells

var xCoord = [], yCoord = [];
for (let x = 1; x < worldWidth-1; x++)
    xCoord.push(x);
for (let y = worldHeight - 2; y >= 1; y--)
    yCoord.push(y);

function shuffleArray(array) 
{
    for (let i = array.length - 1; i >= 0; i--) 
    {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

// GPU-based rendering
var vertexShaderCode = `#version 300 es
in vec2 vertexPosition;
out vec2 UV;

void main() {
    UV = vertexPosition * 0.5 + 0.5;
    gl_Position = vec4(vertexPosition, 0.0, 1.0);
}
`;

var fragmentShaderCode = `#version 300 es
precision mediump float;
in vec2 UV;
uniform sampler2D u_texture;
out vec4 fragColor;

void main() 
{
    fragColor = texture(u_texture, UV);
}
`;

run();

// optional: user code
function initialize()
{
    currentTime = performance.now();
    previousTime = performance.now();

    initializeTexture();
    initializeWorld();
}

// call after shader program initialized
function initializeTexture()
{
    // set up random texture
    texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);

    if (!pixelData)
        pixelData = new Uint8Array(textureWidth * textureHeight * 4);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureWidth, textureHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    // program already compiled; set uniform data
    gl.useProgram(shaderProgram); // avoid a warning message
    const uTextureLocation = gl.getUniformLocation(shaderProgram, "u_texture");
    gl.uniform1i(uTextureLocation, 0); // only one texture, uses slot 0
}

function updateWorld()
{
    // indicate able to move 
    //  -and- activate particles now (only affects those that switched state last update)
    for (let y = 0; y < worldHeight; y++)
        for (let x = 0; x < worldWidth; x++)
        {
            clearMoved(x,y);
            setActive(x,y);
        }

    // redraw borders on all sides (either WALL or HOLE), avoids out-of-bounds array index errors when moving particles
    for (let x = 0; x < worldWidth; x++)
    {
        setParticleFromType(x, 0, borderType);
        setParticleFromType(x, worldHeight-1, borderType);
    }
    for (let y = 0; y < worldHeight; y++)
    {
        setParticleFromType(0, y, borderType);
        setParticleFromType(worldWidth-1, y, borderType);
    }

    // use to randomize order in which particles are processed
    shuffleArray(xCoord);
    // shuffleArray(yCoord); // in some ways looks better but introduces visual stripe artifacts and exacerbates "climbing particles" issue

    // FIRST: process all particle interactions
    // (must process reactions first, otherwise, particles get skipped as they move around)
    for (let j = 0; j < yCoord.length; j++)
    {
        y = yCoord[j]; 
        for (let i = 0; i < xCoord.length; i++)
        {
            x = xCoord[i];

            particleType = getType(x,y);

            // animation "sparkle" effects
            if ( getType(x,y) == HOLE || getType(x,y) == CLONE || getType(x,y) == VIRUS )
                addRandom(x,y,1);

            // special interactions
            if ( particleType == HOLE && isActive(x,y) )
            {
                for (let i = 0; i < 8; i++)
                {
                    if ( getType(x+offsets[i][0], y+offsets[i][1]) != HOLE )
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], AIR);
                }
            }
            else if ( particleType == VIRUS && isActive(x,y) )
            {
                for (let i = 0; i < 8; i++)
                {
                    neighborType = getType(x+offsets[i][0], y+offsets[i][1]);
                    if ( isActive(x,y) && neighborType != AIR && neighborType != VIRUS )
                    {
                        clearActive(x,y);
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], VIRUS);
                    }
                }
            }
            else if ( particleType == CLONE && isActive(x,y) )
            {   
                for (let i = 0; i < 8; i++)
                {
                    neighborType = getType(x+offsets[i][0], y+offsets[i][1]);
                    if (neighborType != CLONE && neighborType != AIR && neighborType != WALL)
                        setParticleFromType(x-offsets[i][0], y-offsets[i][1], neighborType);
                }
            }

            // element-element reactions
            particleType = getType(x,y);
            if ( transmuteTypes.includes(particleType) && isActive(x,y) )
            {
                for (let i = 0; i < 8; i++)
                {
                    // need to recheck type/active since they may change during loop
                    particleType = getType(x,y);
                    neighborType = getType(x+offsets[i][0], y+offsets[i][1]);
                    if ( !isActive(x,y) || !isActive(x+offsets[i][0], y+offsets[i][1]) )
                        continue;

                    if ( particleType == FIRE && neighborType == OIL )
                    {
                        clearActive(x,y); // each particle can only affect 1 neighbor per tick
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], FIRE);
                    }
                    else if ( particleType == FIRE && neighborType == WATER )
                    {
                        setParticleFromType(x,y, AIR); // extinguished
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], VAPOR);
                    }
                    else if ( particleType == FIRE && neighborType == PLANT )
                    {
                        clearActive(x,y); // each particle can only affect 1 neighbor per tick
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], FIRE);
                        setRigid(x+offsets[i][0], y+offsets[i][1]); // burning PLANT remains stationary
                    }
                    else if ( particleType == FIRE && neighborType == ICE )
                    {
                        setParticleFromType(x,y, AIR); // extinguished
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], WATER);
                    }
                    else if ( particleType == FIRE && neighborType == SAND )
                    {
                        clearActive(x,y); // each particle can only affect 1 neighbor per tick
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], LAVA);
                    }
                    else if ( particleType == FIRE && neighborType == MUD )
                    {
                        setParticleFromType(x,y, AIR); // extinguished
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], SAND);
                    }
                    else if ( particleType == FIRE && neighborType == AIR )
                    {
                        addValue(x,y, -1);
                        if ( getValue(x,y) == 0 )
                            setParticleFromType(x,y, AIR); // cooled | burnt out
                    }
                    else if ( particleType == LAVA && neighborType == OIL )
                    {
                        clearActive(x,y); // each particle can only affect 1 neighbor per tick
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], FIRE);
                    }
                    else if ( particleType == LAVA && neighborType == WATER )
                    {
                        setParticleFromType(x,y, ROCK);
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], VAPOR);
                    }
                    else if ( particleType == LAVA && neighborType == PLANT )
                    {
                        clearActive(x,y); // each particle can only affect 1 neighbor per tick
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], FIRE);
                        setRigid(x+offsets[i][0], y+offsets[i][1]); // burning PLANT remains stationary
                    }
                    else if ( particleType == LAVA && neighborType == ICE )
                    {
                        setParticleFromType(x,y, ROCK);
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], WATER);
                    }
                    else if ( particleType == LAVA && neighborType == MUD )
                    {
                        setParticleFromType(x,y, ROCK);
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], SAND);
                    }
                    else if ( particleType == LAVA && neighborType == AIR )
                    {
                        // TODO
                    }
                    else if ( particleType == PLANT && neighborType == WATER )
                    {
                        // TODO PLANT
                    }
                    else if ( particleType == PLANT && neighborType == MUD )
                    {
                        // TODO PLANT
                    }
                    else if ( particleType == ICE && neighborType == VAPOR )
                    {
                        setParticleFromType(x,y, WATER);
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], WATER);
                    }
                    else if ( particleType == ICE && neighborType == AIR )
                    {
                        // TODO WATER
                    }
                    else if ( particleType == WATER && neighborType == SAND )
                    {
                        setParticleFromType(x,y, AIR);
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], MUD);
                    }
                    else if ( particleType == MUD && neighborType == AIR ) 
                    {
                        // TODO SAND
                    }
                    else if ( particleType == VAPOR && neighborType == AIR ) 
                    {
                        // TODO WATER
                    }
                    // 20 interactions
                }
            }

        }       
    }

    // SECOND: process all particle movements
    for (let j = 0; j < yCoord.length; j++)
    {
        y = yCoord[j]; 
        for (let i = 0; i < xCoord.length; i++)
        {
            x = xCoord[i];

            // things that can't move or have already moved are skipped.
            if ( !couldMove(x,y) )
                continue;

            let s = 2 * Math.floor(2 * Math.random()) - 1; // is either +1 or -1
            if ( canSwapVert(x,y, x+0,y+1) )
                doSwap(x,y, x+0,y+1);
            else if ( canSwapDiag(x,y, x-s,y+1) )
                doSwap(x,y, x-s,y+1);
            else if ( canSwapDiag(x,y, x+s,y+1) )
                doSwap(x,y, x+s,y+1);
            else if ( canSwapHoriz(x,y, x-s,y+0) )
                doSwap(x,y, x-s,y+0);
            else if ( canSwapHoriz(x,y, x+s,y+0) )
                doSwap(x,y, x+s,y+0);
        }
    }
}

function canSwapVert( px, py, qx, qy )
{
    // requires: this particle type is heavier/denser than the other particle directly below it
     /// AND the particle directly below is less dense than the ones on the diag below
     // (b/c if the diag areas are empty, they provide less resistance and the main particle would fall to the side instead)
     // TODO: AND don't let solids pass through other solids...
    return couldMove(qx,qy)
        && ( getType(px,py) > getType(qx,qy) )
        && ( !couldMove(qx+1,qy) || getType(qx,qy) <= getType(qx+1,qy) )
        && ( !couldMove(qx-1,qy) || getType(qx,qy) <= getType(qx-1,qy) )
        && ( !(isSolid(px,py) && isSolid(qx,qy)) );
}

function canSwapDiag( px, py, qx, qy )
{
    // requires: there is no particle to the side of this particle that would fall down
    // *and* this particle is heavier/denser than the other particle diagonally below it
    return couldMove(qx,qy)
        && !canSwapVert(qx,qy-1, qx,qy)
        && (getType(px,py) > getType(qx,qy))
        && ( !(isSolid(px,py) && isSolid(qx,qy)) );;
}

function canSwapHoriz( px, py, qx, qy )
{
    // only liquids (non-solids) move horizontally, displacing only other liquids/gases
    return couldMove(qx,qy)
        && !isSolid(px,py)
        && (getType(px,py) > getType(qx,qy))
        && !canSwapVert(qx,qy-1, qx,qy);
}

function doSwap( px, py, qx, qy )
{
    pValue = getParticle(px,py);
    setParticleFromValue(px,py, getParticle(qx,qy));
    setParticleFromValue(qx,qy, pValue);

    // AIR can move again, but nothing else can
    if ( getType(px, py) != AIR )
        setMoved(px, py);
    if ( getType(qx, qy) != AIR )
        setMoved(qx, qy);
}

function convertWorldDataToPixelData()
{
    i = 0;
    for (let y = worldHeight - 1; y >= 0; y--)
    {
        for (let x = 0; x < worldWidth; x++)
        {
            particleType = getType(x,y);

            offsetValue = 4 * (getRandom(x,y) - 5);
            pixelData[i + 0] = colorArray[ particleType ][0] + offsetValue; // Red
            pixelData[i + 1] = colorArray[ particleType ][1] + offsetValue; // Green
            pixelData[i + 2] = colorArray[ particleType ][2] + offsetValue; // Blue
            pixelData[i + 3] = colorArray[ particleType ][3] = ((particleType == FIRE) ? 50 : 255); // Alpha

            i += 4;
        }
        // console.log(i)
    }
}

function sendPixelDataToTexture()
{
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureWidth, textureHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
}

function drawParticles()
{
    r = 2;

    for (let dx = 0; dx < r; dx++)
        for (let dy = 0; dy < r; dy++)
            if ( isValid(mousePixelX + dx, mousePixelY + dy) )
                setParticleFromType( mousePixelX + dx, mousePixelY + dy, selectedType );

    
}

function updateTimer()
{
    currentTime = performance.now();
    deltaTime = (currentTime - previousTime) / 1000.0;
    elapsedTime += deltaTime;
    previousTime = currentTime;
    tick++;
    
    fpsTimer += deltaTime;
    fpsTicker++;

    if (fpsTimer >= 1.0)
    {
        console.log("FPS: " + fpsTicker);
        fpsTimer = 0;
        fpsTicker = 0;
    }
}

// optional: user code
function update()
{
    currentTime = performance.now();
    deltaTime = (currentTime - previousTime) / 1000.0;
    elapsedTime += deltaTime;
    previousTime = currentTime;
    tick++;
    
    fpsTimer += deltaTime;
    fpsTicker++;

    if (fpsTimer >= 1.0)
    {
        console.log("FPS: " + fpsTicker);
        fpsTimer = 0;
        fpsTicker = 0;
    }

    updateWorld();
    convertWorldDataToPixelData();
    sendPixelDataToTexture();
}

function run()
{
    // user defined initialization
    webGLsetup();
    initialize();

    // start two loops that run at different rates:

    // simulation (world) updates runs at user-selected speed. (also, record actual FPS data here)
    // drawing and rendering should run at screen refresh rate (via requestAnimationFrame)
    // loop();
    simulationLoop();
    drawRenderLoop();
}



function simulationLoop()
{
    // control update rate - can attain speed beyond refresh rate ?!
    timeoutID = setTimeout( loop, loopSpeed ); 
    
    updateTimer();
    updateWorld();
    convertWorldDataToPixelData();
    sendPixelDataToTexture();
}

function drawRenderLoop()
{
    // call function on next screen refresh (typically approx 1/60 sec)
	requestAnimationFrame( drawRenderLoop );
    
    if (mouseDown)
    {
        drawParticles();
        // since world has changed, update texture and send
        convertWorldDataToPixelData();
        sendPixelDataToTexture();
    }
    
    render();
}

function loop() 
{
    // call function on next screen refresh (typically approx 1/60 sec)
	// requestAnimationFrame( loop );
    // control update rate - can attain speed beyond refresh rate ?!
    setTimeout( loop, loopSpeed ); 
    // user defined updates
    update();
    render();
}

// render the texture to the canvas
function render()
{ 
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(shaderProgram);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

var mouseDown = false, mousePixelX = 0, mousePixelY = 0;
function onMouseDown(event)
{
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    mousePixelX = (x / (canvasWidth/worldWidth)) | 0;
    mousePixelY = (y / (canvasHeight/worldHeight)) | 0;
    mouseDown = true;    
}

function onMouseMove(event)
{
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    mousePixelX = (x / (canvasWidth/worldWidth)) | 0;
    mousePixelY = (y / (canvasHeight/worldHeight)) | 0;
}

function onMouseUp(event)
{
    mouseDown = false;
}

function onKeyDown(event)
{
    if (event.keyCode >= 48 && event.keyCode <= 57)
        selectedType = event.keyCode - 48;
}

function webGLsetup() 
{
    canvas = document.querySelector("#glcanvas");
    canvas.width = textureWidth;
    canvas.height = textureHeight;
    canvas.style = `width: ${canvasWidth}; height: ${canvasHeight}px; image-rendering: pixelated;`

    canvas.addEventListener("mousedown",  onMouseDown);
    canvas.addEventListener("mousemove",  onMouseMove);
    canvas.addEventListener("mouseup",    onMouseUp);
    canvas.addEventListener("mouseleave", onMouseUp);
    canvas.addEventListener("touchstart", onMouseDown);
    canvas.addEventListener("touchmove",  onMouseMove);
    canvas.addEventListener("touchend",   onMouseUp);

    document.addEventListener("keydown",  onKeyDown);
    
    gl = canvas.getContext("webgl2");

    if (gl == null) 
    {
        console.error( "Unable to initialize WebGL 2." );
        return;
    }

    gl.clearColor(0.0, 0.0, 0.0, 1.0);

    shaderProgram = initProgram(gl, vertexShaderCode, fragmentShaderCode);

    var vertexPositionLocation = gl.getAttribLocation(shaderProgram, "vertexPosition");

    const positions = [1.0, 1.0,   -1.0, 1.0,   1.0, -1.0,   -1.0, -1.0];
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    const numComponents = 2;
    const type = gl.FLOAT;
    const normalize = false;
    const stride = 0;
    const offset = 0;
    gl.vertexAttribPointer( vertexPositionLocation, numComponents, type, normalize, stride, offset );
    
    gl.enableVertexAttribArray( vertexPositionLocation );
}

function loadShader(gl, shaderType, source) 
{
    const shader = gl.createShader(shaderType);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if ( !gl.getShaderParameter(shader, gl.COMPILE_STATUS) ) 
    {
        const message = "Shader Error: " + gl.getShaderInfoLog(shader);
        console.error(message);
        gl.deleteShader(shader);
        return null;
    }

    return shader;
}

function initProgram(gl, vsSource, fsSource)
{
    const vertexShader   = loadShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if ( !gl.getProgramParameter(program, gl.LINK_STATUS) ) 
    {
        const message = "Program Error: " + gl.getProgramInfoLog(program);
        console.error(message);
        gl.deleteProgram(program);
        return null;
    }

    return program;
}

</script>

</html>