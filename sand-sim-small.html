<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>WebGL Demo</title>
    <style>

        *
        {
            font-family:Verdana, Geneva, Tahoma, sans-serif; 
            font-size: 18px;
            font-weight: bold;
        }

        body
        {
            background-color: #AAAAAA;
        }

        .body-div
        {
            background-color: #BBBBAA;
            width: 100%;
            height: 100%;
            padding: 16px;
        }

        button
        {
            width: 140px;
            margin: 0px 4px 0px 4px;
            height: 50px;
            border: 2px solid black;
            border-radius: 8px;
            background-color: #8899AA;
        }

        .active 
        {
            outline: 4px solid white;
        }

        .font-bw
        {
            color: black;
            text-shadow: 0px 0px 1px white,
                0px 0px 2px white,
                0px 0px 3px white,
                0px 0px 4px white,
                0px 0px 5px white,
                0px 0px 6px white,
                0px 0px 7px white,
                0px 0px 8px white;
        }

        .font-wb
        {
            color: white;
            text-shadow: 0px 0px 1px black,
                0px 0px 2px black,
                0px 0px 3px black,
                0px 0px 4px black,
                0px 0px 5px black,
                0px 0px 6px black,
                0px 0px 7px black,
                0px 0px 8px black;
        }

        td
        {
            text-align: center;
            border: 0px solid black;
            height: 32px;
        }

        .small-caps
        {
            font-variant: small-caps;
        }

    </style>
</head>

<body>

<div class="body-div">

<table>
    <tr>
        <td rowspan="12"><canvas id="glcanvas" width="512" height="512"></canvas></td>
        <td class="font-bw small-caps"><u>Elements</u></td>
        <td class="font-bw small-caps"><u>Specials</u></td>
        <td class="font-wb small-caps"><u>Brush Size</u></td>
    </tr>
    <tr>
        <td><button id="vaporButton"   class="font-bw" style="background-color: rgb(160, 180, 210);">Vapor</button></td>
        <td><button id="barrierButton" class="font-bw" style="background-color: rgb(160, 130, 100);">Barrier</button></td>
        <td><button id="smallButton"   class="font-wb">Small</button></td>
    </tr>
    <tr>
        <td><button id="airButton"     class="font-bw" style="background-color: rgb( 20,  20,  20);">Air</button></td>
        <td><button id="virusButton"   class="font-bw" style="background-color: rgb(235, 180, 180);">Virus</button></td>
        <td><button id="largeButton"   class="font-wb">Large</button></td>
    </tr>
    <tr>
        <td><button id="fireButton"    class="font-bw" style="background-color: rgb(235,  20,  20);">Fire</button></td>
        <td><button id="cloneButton"   class="font-bw" style="background-color: rgb(150, 235, 150);">Clone</button></td>
    </tr>
    <tr>
        <td><button id="oilButton"     class="font-bw" style="background-color: rgb(150,  20, 180);">Oil</button></td>
        <td><button id="mutateButton"  class="font-bw" style="background-color: rgb(160, 120, 200);">Mutate</button></td>
    </tr>
    <tr>
        <td><button id="waterButton"   class="font-bw" style="background-color: rgb( 20,  20, 235);">Water</button></td>
        <td><button id="holeButton"    class="font-bw" style="background-color: rgb( 50,  50,  50);">Hole</button></td>
    </tr>
    <tr>
        <td><button id="lavaButton"    class="font-bw" style="background-color: rgb(235, 128,  20);">Lava</button></td>
        <td class="font-wb small-caps"><u>Speed</u></td>
    </tr>
    <tr>
        <td><button id="plantButton"   class="font-bw" style="background-color: rgb( 20, 180,  20);">Plant</button></td>
        <td><button id="pauseButton" class="font-wb">Pause</button></td>
        <td class="font-wb small-caps"><u>General</u></td>
    </tr>
    <tr>
        <td><button id="mudButton"     class="font-bw" style="background-color: rgb(150,  90,  30);">Mud</button></td>
        <td><button id="slowestButton" class="font-wb">Slow</button></td>
        <td><button id="resetButton"   class="font-wb">Reset</button></td>
    </tr>
    <tr>
        <td><button id="iceButton"     class="font-bw" style="background-color: rgb(100, 200, 235);">Ice</button></td>
        <td><button id="slowButton" class="font-wb">Moderate</button></td>
        <td></td>
    </tr>
    <tr>
        <td><button id="sandButton"    class="font-bw" style="background-color: rgb(235, 235,  20);">Sand</button></td>
        <td><button id="normalButton" class="font-wb">Normal</button></td>
        <td></td>
    </tr>
    <tr>
        <td><button id="rockButton"    class="font-bw" style="background-color: rgb(150, 150, 150);">Rock</button></td>
        <td><button id="fastButton" class="font-wb">Fast</button></td>
        <td><button id="fullScreenButton" class="font-wb" onclick="toggleFullscreen();">Full Screen</button></td>
    </tr>
        <!--
        ORIGINAL LAYOUT
        <td>
            <u>Elements</u> <br>
            <button id="vaporButton"   class="font-bw" style="background-color: rgb(160, 180, 210);">Vapor</button> <br>
            <button id="airButton"     class="font-bw" style="background-color: rgb( 20,  20,  20);">Air</button> <br>
            <button id="fireButton"    class="font-bw" style="background-color: rgb(235,  20,  20);">Fire</button> <br>
            <button id="oilButton"     class="font-bw" style="background-color: rgb(150,  20, 180);">Oil</button> <br>
            <button id="waterButton"   class="font-bw" style="background-color: rgb( 20,  20, 235);">Water</button> <br>
            <button id="lavaButton"    class="font-bw" style="background-color: rgb(235, 128,  20);">Lava</button> <br>
            <button id="plantButton"   class="font-bw" style="background-color: rgb( 20, 180,  20);">Plant</button> <br>
            <button id="mudButton"     class="font-bw" style="background-color: rgb(150,  90,  30);">Mud</button> <br>
            <button id="iceButton"     class="font-bw" style="background-color: rgb(100, 200, 235);">Ice</button> <br>
            <button id="sandButton"    class="font-bw" style="background-color: rgb(235, 235,  20);">Sand</button> <br>
            <button id="rockButton"    class="font-bw" style="background-color: rgb(150, 150, 150);">Rock</button> <br>
            <button id="barrierButton" class="font-bw" style="background-color: rgb(160, 130, 100);">Barrier</button> <br>
            <button id="virusButton"   class="font-bw" style="background-color: rgb(235, 180, 180);">Virus</button> <br>
            <button id="cloneButton"   class="font-bw" style="background-color: rgb(150, 235, 150);">Clone</button> <br>
            <button id="mutateButton"  class="font-bw" style="background-color: rgb(160, 120, 200);">Mutate</button> <br>
            <button id="holeButton"    class="font-bw" style="background-color: rgb( 50,  50,  50);">Hole</button>
        </td>
        <td>
            <button id="pauseButton" class="font-wb">Pause</button> <br>
            <button id="slowestButton" class="font-wb">Slow</button> <br>
            <button id="slowButton" class="font-wb">Moderate</button> <br>
            <button id="normalButton" class="font-wb">Normal</button> <br>
            <button id="fastButton" class="font-wb">Fast</button>
        </td>
        -->
    </tr>
</table>

</div>

</body>

<script>

var canvas, gl, world,
worldWidth = textureWidth = 100,  
worldHeight = textureHeight = 100, 
canvasWidth = 650, canvasHeight = 650,
pixelData, texture, shaderProgram,
currentTime, previousTime, deltaTime, elapsedTime, tick = 0, fpsTimer = 0, fpsTicker = 0; 

// UI information
var activeSpeedButtonId;

var loopSpeed = 16, paused = false;
document.getElementById("pauseButton"  ).addEventListener("click", (event) => { selectSpeed(event.srcElement.id,   -1); } );
document.getElementById("slowestButton").addEventListener("click", (event) => { selectSpeed(event.srcElement.id, 1000); } );
document.getElementById("slowButton"   ).addEventListener("click", (event) => { selectSpeed(event.srcElement.id,  100); } );
document.getElementById("normalButton" ).addEventListener("click", (event) => { selectSpeed(event.srcElement.id,   16); } );
document.getElementById("fastButton"   ).addEventListener("click", (event) => { selectSpeed(event.srcElement.id,    4); } );

function selectSpeed( id, speed )
{
    // change style of previously active button
    if (activeSpeedButtonId != null)
        document.getElementById(activeSpeedButtonId).classList.remove("active");

    // update with new information
    activeSpeedButtonId = id;
    document.getElementById(activeSpeedButtonId).classList.add("active");
    paused    = (speed < 0);
    loopSpeed = (speed > 0) ? speed : loopSpeed;
}

document.getElementById("normalButton").click();

var activeSizeButtonId;

document.getElementById("smallButton").addEventListener("click", (event) => { selectDrawRadius(event.srcElement.id, 1); } );
document.getElementById("largeButton").addEventListener("click", (event) => { selectDrawRadius(event.srcElement.id, 3); } );
function selectDrawRadius( id, size )
{
    // change style of previously active button
    if (activeSizeButtonId != null)
        document.getElementById(activeSizeButtonId).classList.remove("active");

    // update with new information
    activeSizeButtonId = id;
    document.getElementById(activeSizeButtonId).classList.add("active");
    drawRadius = size;
}

document.getElementById("largeButton").click();

document.getElementById("resetButton").addEventListener("click", (event) => { initializeWorld(); convertWorldDataToPixelData(); sendPixelDataToTexture(); } );


/**
 *   Each point in the world is represented by a number;
 *     int = data structure via bits 
 * 
 *  14 bit int: SLGRIMVVVVTTTT
 * 
 *  TODO: A SLG FAM VVVVVVVV RRRR TTTT
 * 
 *  TTTT: type (e.g. ), 0-15, also used for base color, also used for relative density (some particles fall through others)
 *  VVVV: random value, 0-10, used for RGB color variation
 *  R: Rigid,  true/false (1/0), affected by gravity?
 *  A: Active, true/false (1/0), can interact with other particles? (must have existed for at least one tick)
 *  M: Moved,  true/false (1/0), did the particle move during this cycle? (particles only move once) 
 *  S: Solid,  true/false (1/0), is Solid? (is only displaced in L/R direction, by heavier particles (other solids))
 *  L: Liquid, true/false (1/0), is Liquid? (can be displaced in any direction, by heavier particles. can flow L/R through liquids/gases)
 *  G: Gas,    true/false (1/0), is Gas? (can be displaced in any direction, by heavier particles. can flow L/R through gases)
 *  [[ additional bits could be specified later to store more properties or data ]]
 *  
 */

const TYPE_BITS   = [0,1,2,3], 
      RANDOM_BITS = [4,5,6,7],
      VALUE_BITS  = [8,9,10,11,12,13,14,15], // max val 2^8 = 256
      RIGID_BIT = 16, ACTIVE_BIT = 17, MOVED_BIT = 18,
      SOLID_BIT = 19, LIQUID_BIT = 20,   GAS_BIT = 21,
      ANIMATE_BIT = 22;
      
      // RIGID -> rename to GRAVITY_BIT? or FALL_BIT?
      // ANIMATE_BIT: 22

const VAPOR =  0,   AIR =  1,  FIRE =  2,   
        OIL =  3, WATER =  4,   MUD =  5,   LAVA =  6,
      PLANT =  7,   ICE =  8,  SAND =  9,   ROCK = 10, 
    BARRIER = 11, VIRUS = 12, CLONE = 13, MUTATE = 14, HOLE = 15;

var drawType, borderType = BARRIER;

var     gasTypes = [VAPOR, AIR];
var  liquidTypes = [OIL, WATER, LAVA];
var   solidTypes = [PLANT, MUD, ICE, SAND, ROCK, FIRE]; 
// FIRE is included in list of solids so that it doesn't flow sideways like liquid/gas
// FIRE has low index because "heat rises"

// special types don't affect other special types
var specialTypes = [BARRIER, VIRUS, CLONE, MUTATE, HOLE];

// results of particle mutation (non-special && non-AIR)
var  mutateTypes = [VAPOR, OIL, WATER, LAVA, PLANT, MUD, ICE, SAND, ROCK, FIRE];
function selectRandom(array) { return array[Math.floor(Math.random()*array.length)]; }

// the particle types that can change other particle types
// (also technically AIR, but this is included by the types below, 
//  and checking all neighbors of every AIR each tick would take a lot of time)
var transmuteTypes = [FIRE, LAVA, WATER, ICE, PLANT, MUD, VAPOR]; // change into: [AIR, ROCK, PLANT, WATER, OIL, SAND, WATER]
// reusable variables
var particleType, neighborType;
// used when checking all neighbors of a particle (possible particle-particle interactions)
var offsets = [ [-1,-1], [0,-1], [1,-1], [1,0], [1,1], [0,1], [-1,1], [-1,0] ];

document.getElementById( "vaporButton"   ).addEventListener("click", (event) => { selectDrawType(event.srcElement.id, VAPOR); } );
document.getElementById( "airButton"     ).addEventListener("click", (event) => { selectDrawType(event.srcElement.id, AIR) } );
document.getElementById( "fireButton"    ).addEventListener("click", (event) => { selectDrawType(event.srcElement.id, FIRE) } );
document.getElementById( "oilButton"     ).addEventListener("click", (event) => { selectDrawType(event.srcElement.id, OIL) } );
document.getElementById( "waterButton"   ).addEventListener("click", (event) => { selectDrawType(event.srcElement.id, WATER) } );
document.getElementById( "lavaButton"    ).addEventListener("click", (event) => { selectDrawType(event.srcElement.id, LAVA) } );
document.getElementById( "plantButton"   ).addEventListener("click", (event) => { selectDrawType(event.srcElement.id, PLANT) } );
document.getElementById( "mudButton"     ).addEventListener("click", (event) => { selectDrawType(event.srcElement.id, MUD) } );
document.getElementById( "iceButton"     ).addEventListener("click", (event) => { selectDrawType(event.srcElement.id, ICE) } );
document.getElementById( "sandButton"    ).addEventListener("click", (event) => { selectDrawType(event.srcElement.id, SAND) } );
document.getElementById( "rockButton"    ).addEventListener("click", (event) => { selectDrawType(event.srcElement.id, ROCK) } );
document.getElementById( "barrierButton" ).addEventListener("click", (event) => { selectDrawType(event.srcElement.id, BARRIER) } );
document.getElementById( "virusButton"   ).addEventListener("click", (event) => { selectDrawType(event.srcElement.id, VIRUS) } );
document.getElementById( "cloneButton"   ).addEventListener("click", (event) => { selectDrawType(event.srcElement.id, CLONE) } );
document.getElementById( "mutateButton"  ).addEventListener("click", (event) => { selectDrawType(event.srcElement.id, MUTATE) } );
document.getElementById( "holeButton"    ).addEventListener("click", (event) => { selectDrawType(event.srcElement.id, HOLE) } );

var activeParticleButtonId;
function selectDrawType( id, type )
{
    // change style of previously active button
    if (activeParticleButtonId != null)
        document.getElementById(activeParticleButtonId).classList.remove("active");

    // update with new information
    activeParticleButtonId = id;
    document.getElementById(activeParticleButtonId).classList.add("active");
    drawType = type;
}

document.getElementById("rockButton").click();

var colorArray = [];
colorArray[VAPOR]   = [160, 180, 210, 255]; // white (just a hint of blue)
colorArray[AIR]     = [ 20,  20,  20, 255]; // black
colorArray[FIRE]    = [235,  40,  40, 255]; // red
colorArray[OIL]     = [150,  20, 180, 255]; // purple
colorArray[WATER]   = [ 20,  20, 235, 255]; // blue
colorArray[LAVA]    = [235, 128,  20, 255]; // orange
colorArray[PLANT]   = [ 20, 180,  20, 255]; // green
colorArray[MUD]     = [150,  90,  30, 255]; // brown
colorArray[ICE]     = [100, 200, 235, 255]; // light blue
colorArray[SAND]    = [235, 235,  20, 255]; // yellow
colorArray[ROCK]    = [150, 150, 150, 255]; // light gray
colorArray[BARRIER] = [170, 140, 110, 255]; // light brown
colorArray[VIRUS]   = [235, 180, 180, 255]; // light red
colorArray[CLONE]   = [150, 235, 150, 255]; // light green
colorArray[MUTATE]  = [160, 120, 200, 255]; // light purple
colorArray[HOLE]    = [ 50,  50,  50, 255]; // dark gray

// for particle at position (x,y), change bit at index N to 1
function setBit( x,y, N ) { world[y][x] = world[y][x] | (1 << N); }

// for particle at position (x,y), change bit at index N to 0
function clearBit( x,y, N ) { world[y][x] = world[y][x] & (~(1 << N)); }

// for particle at position (x,y), get bit at index N
// since Javascript is "truthy", can interpret these as boolean values
function getBit( x,y, N ) { return (world[y][x] & (1 << N)) >> N; }

// check states
function isRigid( x,y )  { return getBit(x,y, RIGID_BIT); }
function isActive( x,y ) { return getBit(x,y, ACTIVE_BIT); }
function isMoved( x,y )  { return getBit(x,y, MOVED_BIT); }
function isSolid( x,y )  { return getBit(x,y, SOLID_BIT); }
function isLiquid( x,y ) { return getBit(x,y, LIQUID_BIT); }
function isGas( x,y )    { return getBit(x,y, GAS_BIT); }

// state = true
function setRigid( x,y )  { setBit(x,y, RIGID_BIT); }
function setActive( x,y ) { setBit(x,y, ACTIVE_BIT); }
function setMoved( x,y )  { setBit(x,y, MOVED_BIT); }
function setSolid( x,y )  { setBit(x,y, SOLID_BIT); }
function setLiquid( x,y ) { setBit(x,y, LIQUID_BIT); }
function setGas( x,y )    { setBit(x,y, GAS_BIT); }

// state = false
function clearRigid( x,y )  { clearBit(x,y, RIGID_BIT); }
function clearActive( x,y ) { clearBit(x,y, ACTIVE_BIT); }
function clearMoved( x,y )  { clearBit(x,y, MOVED_BIT); }

// reset particle
function clearAll( x,y ) { world[y][x] = 0; }

// set type bits to a given value
function setType( x,y, t ) { world[y][x] = (world[y][x] & ~(0b1111 << 0)) | (t << 0); }
function getType( x,y )    { return world[y][x] & 0b1111; }

// set random bits to a given number, 0 <= r <= 10
function clearRandom( x,y )  { world[y][x] = world[y][x] & ~(0b1111 << 4); }
function setRandom( x,y, r ) { world[y][x] = (world[y][x] & ~(0b1111 << 4)) | (r << 4); }
function getRandom( x,y )    { return (world[y][x] & (0b1111 << 4)) >> 4; }
function addRandom( x,y, v ) { setRandom( x,y, (getRandom(x,y)+v+11)%11 ); } // wraparound desired for shimmer animation

// set value bits to a given number, 0 <= r <= 255
function clearValue( x,y )  { world[y][x] = world[y][x] & ~(0b11111111 << 8); }
function setValue( x,y, r ) { world[y][x] = (world[y][x] & ~(0b11111111 << 8)) | (r << 8); }
function getValue( x,y )    { return (world[y][x] & (0b11111111 << 8)) >> 8; }
function addValue( x,y, v ) { setValue( x,y, getValue(x,y)+v ); return getValue(x,y); } // careful to avoid wraparound...

// set all particle properties based on type
function setParticleFromType( x,y, pType )
{
    clearAll(x,y);
    setType(x,y, pType);
    
    // everything except AIR has random coloring
    if ( pType != AIR )
        setRandom( x,y, Math.floor(10 * Math.random()) );

    if ( gasTypes.includes(pType) )
        setGas(x,y);
    else if ( liquidTypes.includes(pType) )
        setLiquid(x,y);
    else // if ( solidTypes.includes(pType) ) 
        setSolid(x,y);

    // things that will never move
    if ( pType == PLANT || specialTypes.includes(pType) )
        setRigid(x,y);

    // special values all start at 0, increase on exposure to a specific element,
    //   then transmute when value reaches 255
    clearValue(x,y);

    // ACTIVE is always set (to true) at beginning of particle processing
    //   does not apply to particles just transformed from interactions
    clearActive(x,y);
    // MOVED may be set during particle processing
    clearMoved(x,y);
}

function setParticleFromValue(x,y, v) { world[y][x] = v; }
function getParticle(x,y) { return world[y][x]; }

// check if coordinates are within world range
function isValid(x,y) { return (0 <= x) && (x < worldWidth) && (0 <= y) && (y < worldHeight); }

function couldMove(x,y) { return !isMoved(x,y) && !isRigid(x,y); }

function initializeWorld()
{
    // remember! y-by-x = rows-by-columns = height-by-width
    world = [];
    for (let y = 0; y < worldHeight; y++)
        world.push( new Array(worldWidth).fill(0) );

    for (let y = 0; y < worldHeight; y++)
        for (let x = 0; x < worldWidth; x++)
            setParticleFromType(x,y, AIR);

    // set borders on all sides (either BARRIER or HOLE), avoids out-of-bounds array index errors
    for (let x = 0; x < worldWidth; x++)
    {
        setParticleFromType(x, 0, borderType);
        setParticleFromType(x, worldHeight-1, borderType);
    }
    for (let y = 0; y < worldHeight; y++)
    {
        setParticleFromType(0, y, borderType);
        setParticleFromType(worldWidth-1, y, borderType);
    }
}

// avoid unusual behaviors arising from left-to-right processing
//   by processing coordinates in a random order.
//   does *not* include border cells

var xCoord = [], yCoord = [];
for (let x = 1; x < worldWidth-1; x++)
    xCoord.push(x);
for (let y = worldHeight - 2; y >= 1; y--)
    yCoord.push(y);

function shuffleArray(array) 
{
    for (let i = array.length - 1; i >= 0; i--) 
    {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

// GPU-based rendering
var vertexShaderCode = `#version 300 es
in vec2 vertexPosition;
out vec2 UV;

void main() {
    UV = vertexPosition * 0.5 + 0.5;
    gl_Position = vec4(vertexPosition, 0.0, 1.0);
}
`;

var fragmentShaderCode = `#version 300 es
precision mediump float;
in vec2 UV;
uniform sampler2D u_texture;
out vec4 fragColor;

void main() 
{
    fragColor = texture(u_texture, UV);
}
`;

run();

// optional: user code
function initialize()
{
}

// call after shader program initialized
function initializeTexture()
{
    // set up random texture
    texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);

    if (!pixelData)
        pixelData = new Uint8Array(textureWidth * textureHeight * 4);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureWidth, textureHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    // program already compiled; set uniform data
    gl.useProgram(shaderProgram); // avoid a warning message
    const uTextureLocation = gl.getUniformLocation(shaderProgram, "u_texture");
    gl.uniform1i(uTextureLocation, 0); // only one texture, uses slot 0
}

function updateWorld()
{
    // indicate able to move 
    //  -and- activate particles now (only affects those that switched state last update)
    for (let y = 0; y < worldHeight; y++)
        for (let x = 0; x < worldWidth; x++)
        {
            clearMoved(x,y);
            setActive(x,y);
        }

    // redraw borders on all sides (either BARRIER or HOLE), avoids out-of-bounds array index errors when moving particles
    for (let x = 0; x < worldWidth; x++)
    {
        setParticleFromType(x, 0, borderType);
        setParticleFromType(x, worldHeight-1, borderType);
    }
    for (let y = 0; y < worldHeight; y++)
    {
        setParticleFromType(0, y, borderType);
        setParticleFromType(worldWidth-1, y, borderType);
    }

    // use to randomize order in which particles are processed
    shuffleArray(xCoord);
    // shuffleArray(yCoord); // in some ways looks better but introduces visual stripe artifacts and exacerbates "climbing particles" issue

    // FIRST: process all particle interactions
    // (must process reactions first, otherwise, particles get skipped as they move around)
    for (let j = 0; j < yCoord.length; j++)
    {
        y = yCoord[j]; 
        for (let i = 0; i < xCoord.length; i++)
        {
            x = xCoord[i];

            particleType = getType(x,y);

            // animation "sparkle" effects for special types of particles
            // if ( specialTypes.includes(particleType) )
            //    addRandom(x,y,1);

            // special interactions
            if ( particleType == HOLE && isActive(x,y) )
            {
                for (let i = 0; i < 8; i++)
                {
                    neighborType = getType(x+offsets[i][0], y+offsets[i][1]);
                    if ( !specialTypes.includes( neighborType ) )
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], AIR);
                }
            }
            else if ( particleType == VIRUS && isActive(x,y) )
            {
                for (let i = 0; i < 8; i++)
                {
                    neighborType = getType(x+offsets[i][0], y+offsets[i][1]);
                    if ( isActive(x,y) && neighborType != AIR && !specialTypes.includes( neighborType ) )
                    {
                        clearActive(x,y);
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], VIRUS);
                    }
                }
            }
            else if ( particleType == CLONE && isActive(x,y) )
            {   
                for (let i = 0; i < 8; i++)
                {
                    neighborType = getType(x+offsets[i][0], y+offsets[i][1]);
                    if (neighborType == CLONE)
                    {
                        if ( x%2 == 0 && y%2 == 0 )
                            setParticleFromType(x+offsets[i][0], y+offsets[i][1], AIR);
                        else
                            setParticleFromType(x,y, AIR);
                    }
                    else if (neighborType != AIR && !specialTypes.includes( neighborType ))
                        setParticleFromType(x-offsets[i][0], y-offsets[i][1], neighborType);
                }
            }
            else if ( particleType == MUTATE && isActive(x,y) )
            {   
                for (let i = 0; i < 8; i++)
                {
                    neighborType = getType(x+offsets[i][0], y+offsets[i][1]);
                    if (neighborType != AIR && !specialTypes.includes( neighborType ))
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], selectRandom(mutateTypes));

                    // Note: mutate into PLANT not possible since it doesn't move, it keeps changing...
                }
            }

            // element-element reactions
            particleType = getType(x,y);
            if ( transmuteTypes.includes(particleType) && isActive(x,y) )
            {
                for (let i = 0; i < 8; i++)
                {
                    // need to recheck type/active since they may change during loop
                    particleType = getType(x,y);
                    neighborType = getType(x+offsets[i][0], y+offsets[i][1]);
                    if ( !isActive(x,y) || !isActive(x+offsets[i][0], y+offsets[i][1]) )
                        continue;

                    if ( particleType == FIRE && neighborType == OIL )
                    {
                        clearActive(x,y); // each particle can only affect 1 neighbor per tick
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], FIRE);
                    }
                    else if ( particleType == FIRE && neighborType == WATER )
                    {
                        setParticleFromType(x,y, AIR); // extinguished
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], VAPOR);
                    }
                    else if ( particleType == FIRE && neighborType == PLANT )
                    {
                        clearActive(x,y); // each particle can only affect 1 neighbor per tick
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], FIRE);
                        setRigid(x+offsets[i][0], y+offsets[i][1]); // burning PLANT remains stationary
                    }
                    else if ( particleType == FIRE && neighborType == ICE )
                    {
                        setParticleFromType(x,y, AIR); // extinguished
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], WATER);
                    }
                    else if ( particleType == FIRE && neighborType == ROCK )
                    {
                        setParticleFromType(x,y, AIR); // ROCK absorbs FIRE
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], LAVA);
                    }
                    else if ( particleType == FIRE && neighborType == MUD )
                    {
                        setParticleFromType(x,y, AIR); // extinguished
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], SAND);
                    }
                    else if ( particleType == FIRE && neighborType == AIR )
                    {
                        if ( Math.random() < 0.95 && addValue(x,y, 1) == 255 )
                            setParticleFromType(x,y, AIR);
                    }
                    else if ( particleType == LAVA && neighborType == OIL )
                    {
                        clearActive(x,y); // each particle can only affect 1 neighbor per tick
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], FIRE);
                    }
                    else if ( particleType == LAVA && neighborType == WATER )
                    {
                        setParticleFromType(x,y, ROCK);
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], VAPOR);
                    }
                    else if ( particleType == LAVA && neighborType == PLANT )
                    {
                        clearActive(x,y); // each particle can only affect 1 neighbor per tick
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], FIRE);
                        setRigid(x+offsets[i][0], y+offsets[i][1]); // burning PLANT remains stationary
                    }
                    else if ( particleType == LAVA && neighborType == ICE )
                    {
                        setParticleFromType(x,y, ROCK);
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], WATER);
                    }
                    else if ( particleType == LAVA && neighborType == MUD )
                    {
                        // the FIRE in the LAVA=(FIRE+ROCK) and the WATER in the MUD=(WATER+SAND) cancel out
                        setParticleFromType(x,y, ROCK);
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], SAND);
                    }
                    else if ( particleType == LAVA && neighborType == AIR )
                    {
                        if ( Math.random() < 0.20 && addValue(x,y, 1) == 255 )
                            setParticleFromType(x,y, ROCK);
                    }
                    else if ( particleType == WATER && neighborType == PLANT )
                    {
                        if ( Math.random() < 0.50 && addValue(x,y, 1) == 255 )
                            setParticleFromType(x,y, PLANT);
                    }
                    else if ( particleType == PLANT && neighborType == MUD )
                    {
                        if ( Math.random() < 0.10 && addValue(x,y, 1) == 255 )
                            setParticleFromType(x,y, OIL);
                    }
                    else if ( particleType == ICE && neighborType == VAPOR )
                    {
                        setParticleFromType(x,y, WATER);
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], WATER);
                    }
                    else if ( particleType == ICE && neighborType == AIR )
                    {
                        if ( Math.random() < 0.10 && addValue(x,y, 1) == 255 )
                            setParticleFromType(x,y, WATER);
                    }
                    else if ( particleType == WATER && neighborType == SAND )
                    {
                        setParticleFromType(x,y, AIR); // SAND absorbs WATER
                        setParticleFromType(x+offsets[i][0], y+offsets[i][1], MUD);
                    }
                    else if ( particleType == MUD && neighborType == AIR ) 
                    {
                        if ( Math.random() < 0.10 && addValue(x,y, 1) == 255 )
                            setParticleFromType(x,y, SAND);
                    }
                    else if ( particleType == VAPOR && neighborType == AIR ) 
                    {
                        if ( Math.random() < 0.10 && addValue(x,y, 1) == 255 )
                            setParticleFromType(x,y, WATER);
                    }
                    // 20 interactions
                }
            }

        }       
    }

    // SECOND: process all particle movements
    for (let j = 0; j < yCoord.length; j++)
    {
        y = yCoord[j]; 
        for (let i = 0; i < xCoord.length; i++)
        {
            x = xCoord[i];

            // things that can't move or have already moved are skipped.
            if ( !couldMove(x,y) )
                continue;

            let s = 2 * Math.floor(2 * Math.random()) - 1; // is either +1 or -1
            if ( canSwapVert(x,y, x+0,y+1) )
                doSwap(x,y, x+0,y+1);
            else if ( canSwapDiag(x,y, x-s,y+1) )
                doSwap(x,y, x-s,y+1);
            else if ( canSwapDiag(x,y, x+s,y+1) )
                doSwap(x,y, x+s,y+1);
            else if ( canSwapHoriz(x,y, x-s,y+0) )
                doSwap(x,y, x-s,y+0);
            else if ( canSwapHoriz(x,y, x+s,y+0) )
                doSwap(x,y, x+s,y+0);
        }
    }
}

function canSwapVert( px, py, qx, qy )
{
    // requires: this particle type is heavier/denser than the other particle directly below it
     /// AND the particle directly below is less dense than the ones on the diag below
     // (b/c if the diag areas are empty, they provide less resistance and the main particle would fall to the side instead)
     // TODO: AND don't let solids pass through other solids...
    return couldMove(qx,qy)
        && ( getType(px,py) > getType(qx,qy) )
        && ( !couldMove(qx+1,qy) || getType(qx,qy) <= getType(qx+1,qy) )
        && ( !couldMove(qx-1,qy) || getType(qx,qy) <= getType(qx-1,qy) )
        && ( !(isSolid(px,py) && isSolid(qx,qy)) );
}

function canSwapDiag( px, py, qx, qy )
{
    // requires: there is no particle to the side of this particle that would fall down
    // *and* this particle is heavier/denser than the other particle diagonally below it
    return couldMove(qx,qy)
        && !canSwapVert(qx,qy-1, qx,qy)
        && (getType(px,py) > getType(qx,qy))
        && ( !(isSolid(px,py) && isSolid(qx,qy)) );;
}

function canSwapHoriz( px, py, qx, qy )
{
    // only liquids (non-solids) move horizontally, displacing only other liquids/gases
    return couldMove(qx,qy)
        && !isSolid(px,py)
        && (getType(px,py) > getType(qx,qy))
        && !canSwapVert(qx,qy-1, qx,qy);
}

function doSwap( px, py, qx, qy )
{
    pValue = getParticle(px,py);
    setParticleFromValue(px,py, getParticle(qx,qy));
    setParticleFromValue(qx,qy, pValue);

    // AIR can move again, but nothing else can
    if ( getType(px, py) != AIR )
        setMoved(px, py);
    if ( getType(qx, qy) != AIR )
        setMoved(qx, qy);
}

function convertWorldDataToPixelData()
{
    i = 0;
    for (let y = worldHeight - 1; y >= 0; y--)
    {
        for (let x = 0; x < worldWidth; x++)
        {
            if (y == worldHeight-1 || y == 0 || x == worldWidth-1 || x == 0)
            {
                // border colors are black
                pixelData[i + 0] =  42; // Red
                pixelData[i + 1] =  42; // Green
                pixelData[i + 2] =  42; // Blue
                pixelData[i + 3] = 255; // Alpha
            }
            else
            {
                particleType = getType(x,y);
                offsetValue = 4 * (getRandom(x,y) - 5);
                pixelData[i + 0] = colorArray[ particleType ][0] + offsetValue; // Red
                pixelData[i + 1] = colorArray[ particleType ][1] + offsetValue; // Green
                pixelData[i + 2] = colorArray[ particleType ][2] + offsetValue; // Blue
                pixelData[i + 3] = 255; // Alpha
            }
            i += 4;
        }
    }
}

function sendPixelDataToTexture()
{
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureWidth, textureHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
}

function initializeTimer()
{
    currentTime = performance.now();
    previousTime = performance.now();
}

function updateTimer()
{
    currentTime = performance.now();
    deltaTime = (currentTime - previousTime) / 1000.0;
    elapsedTime += deltaTime;
    previousTime = currentTime;
    tick++;
    
    fpsTimer += deltaTime;
    fpsTicker++;

    if (fpsTimer >= 1.0)
    {
        console.log("FPS: " + fpsTicker);
        fpsTimer = 0;
        fpsTicker = 0;
    }
}

function run()
{
    initializeTimer();
    initializeCanvas();
    initializeWebGL();
    initializeTexture();
    initializeWorld();

    // start two loops that run at different rates:

    // simulation (world) updates runs at user-selected speed. (also, record actual FPS data here)
    // drawing and rendering should run at screen refresh rate (via requestAnimationFrame)
    // loop();
    simulationLoop();
    drawRenderLoop();
}

function simulationLoop()
{
    timeoutID = setTimeout( simulationLoop, loopSpeed ); 
    
    if (paused)
        return;

    updateTimer();
    updateWorld();
    convertWorldDataToPixelData();
    sendPixelDataToTexture();
}

function drawRenderLoop()
{
    // call function on next screen refresh (typically approx 1/60 sec)
	requestAnimationFrame( drawRenderLoop );
    
    if (drawActive)
    {
        drawParticles();
        // since world has changed, update texture and send
        convertWorldDataToPixelData();
        sendPixelDataToTexture();
    }
    
    render();
}

var drawActive = false, drawPixelX = 0, drawPixelY = 0, drawRadius;
var lastPixelX = null, lastPixelY = null; // use for drawing lines betweeen pixels

function drawParticles()
{
    // draw a single box
    for (let dx = 0; dx < drawRadius; dx++)
        for (let dy = 0; dy < drawRadius; dy++)
            if ( isValid(drawPixelX + dx, drawPixelY + dy) )
                setParticleFromType( drawPixelX + dx, drawPixelY + dy, drawType );

    // draw all the pixels in a line from last drawn pixel to current drawn pixel
    if (lastPixelX != null)
    {
        let distX = drawPixelX - lastPixelX;
        let distY = drawPixelY - lastPixelY;
        let steps = Math.max( Math.abs(distX), Math.abs(distY) );
        let deltaX = distX / steps;
        let deltaY = distY / steps;
        for (let i = 0; i <= steps; i++)
        {
            let x = Math.round(lastPixelX + i*deltaX);
            let y = Math.round(lastPixelY + i*deltaY);
            // setParticleFromType( Math.round(lastPixelX + i*deltaX), Math.round(lastPixelY + i*deltaY), drawType );
            for (let dx = 0; dx < drawRadius; dx++)
                for (let dy = 0; dy < drawRadius; dy++)
                    if ( isValid(x + dx, y + dy) )
                        setParticleFromType( x + dx, y + dy, drawType );
        }
    }
    lastPixelX = drawPixelX;
    lastPixelY = drawPixelY;
}

function setDrawActiveMouse(event)
{
    drawActive = true; 
    setDrawPixelFromMouse(event);
}

function setDrawActiveTouch(event)
{
    drawActive = true; 
    setDrawPixelFromTouch(event);
}

function setDrawPixelFromMouse(event)
{
    event.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    drawPixelX = (x / (canvasWidth/worldWidth)) | 0;
    drawPixelY = (y / (canvasHeight/worldHeight)) | 0;
}

function setDrawPixelFromTouch(event)
{
    event.preventDefault();  
    const rect = canvas.getBoundingClientRect();
    const x = event.targetTouches[0].pageX - rect.left;
    const y = event.targetTouches[0].pageY - rect.top;
    drawPixelX = (x / (canvasWidth/worldWidth)) | 0;
    drawPixelY = (y / (canvasHeight/worldHeight)) | 0;
}

function setDrawInactive(event)
{
    event.preventDefault();
    drawActive = false;
    lastPixelX = null;
    lastPixelY = null;
}

// render the texture to the canvas
function render()
{ 
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.useProgram(shaderProgram);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

function initializeCanvas()
{
    canvas = document.querySelector("#glcanvas");
    canvas.width = textureWidth;
    canvas.height = textureHeight;
    canvas.style = `width: ${canvasWidth}; height: ${canvasHeight}px; image-rendering: pixelated;`

    canvas.addEventListener("mousedown",  setDrawActiveMouse);
    canvas.addEventListener("mousemove",  setDrawPixelFromMouse);
    canvas.addEventListener("mouseup",    setDrawInactive);
    canvas.addEventListener("mouseleave", setDrawInactive);
    canvas.addEventListener("touchstart", setDrawActiveTouch);
    canvas.addEventListener("touchmove",  setDrawPixelFromTouch);
    canvas.addEventListener("touchend",   setDrawInactive);
}

function initializeWebGL()
{    
    gl = canvas.getContext("webgl2");

    if (gl == null) 
    {
        console.error( "Unable to initialize WebGL 2." );
        return;
    }

    gl.clearColor(0.0, 0.0, 0.0, 1.0);

    shaderProgram = initProgram(gl, vertexShaderCode, fragmentShaderCode);

    var vertexPositionLocation = gl.getAttribLocation(shaderProgram, "vertexPosition");

    const positions = [1.0, 1.0,   -1.0, 1.0,   1.0, -1.0,   -1.0, -1.0];
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    const numComponents = 2;
    const type = gl.FLOAT;
    const normalize = false;
    const stride = 0;
    const offset = 0;
    gl.vertexAttribPointer( vertexPositionLocation, numComponents, type, normalize, stride, offset );
    
    gl.enableVertexAttribArray( vertexPositionLocation );
}

function loadShader(gl, shaderType, source) 
{
    const shader = gl.createShader(shaderType);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if ( !gl.getShaderParameter(shader, gl.COMPILE_STATUS) ) 
    {
        const message = "Shader Error: " + gl.getShaderInfoLog(shader);
        console.error(message);
        gl.deleteShader(shader);
        return null;
    }

    return shader;
}

function initProgram(gl, vsSource, fsSource)
{
    const vertexShader   = loadShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if ( !gl.getProgramParameter(program, gl.LINK_STATUS) ) 
    {
        const message = "Program Error: " + gl.getProgramInfoLog(program);
        console.error(message);
        gl.deleteProgram(program);
        return null;
    }

    return program;
}

function toggleFullscreen(event) 
{
  var element = document.body;

  if (event instanceof HTMLElement) { element = event; }

  var isFullscreen = document.webkitIsFullScreen || document.mozFullScreen || false;

  element.requestFullScreen = element.requestFullScreen || element.webkitRequestFullScreen || element.mozRequestFullScreen || function() {
    return false;
  };
  document.cancelFullScreen = document.cancelFullScreen || document.webkitCancelFullScreen || document.mozCancelFullScreen || function() {
    return false;
  };

  isFullscreen ? document.cancelFullScreen() : element.requestFullScreen();
}

</script>

</html>