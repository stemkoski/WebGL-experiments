<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>WebGL Demo</title>
    <style>
        button
        {
            width:120px;
            margin: 8px;
            padding: 8px;
            border: 2px solid black;
            background-color: lightblue;
            font-size: 20px;
            font-weight: bold;
            color: black;
            text-shadow: 1px 1px 2px rgba(0,0,0, 0.5);
            -xxwebkit-text-stroke-width: 1px;
            -xwebkit-text-stroke-color: black;
            border-radius: 8px;
        }
    </style>
</head>

<body>
<table>
    <tr>
        <td><canvas id="glcanvas" width="512" height="512"></canvas></td>
        <td>
            <button id="slowestButton">Slowest</button> <br>
            <button id="slowButton">Slow</button> <br>
            <button id="fastButton">Fast</button> <br>
            <button id="fastestButton">Fastest</button>
        </td>
    </tr>
</table>
</body>

<script>

var canvas, gl, world,
worldWidth = textureWidth = 200,  
worldHeight = textureHeight = 200, 
canvasWidth = 800, canvasHeight = 800,
pixelData, texture, shaderProgram,
currentTime, previousTime, deltaTime, elapsedTime, tick = 0, fpsTimer = 0, fpsTicker = 0; 

var loopSpeed = 16;
// 16 elements
// 4 speeds, pause, reset
// TODO: draw speed separate from world update speed!
document.getElementById("slowestButton").addEventListener("click", () => { loopSpeed = 1000 } );
document.getElementById("slowButton").addEventListener("click", () => { loopSpeed = 100 } );
document.getElementById("fastButton").addEventListener("click", () => { loopSpeed = 16 } );
document.getElementById("fastestButton").addEventListener("click", () => { loopSpeed = 1 } );

/**
 *   Each point in the world is represented by a number;
 *     int = data structure via bits 
 * 
 *  14 bit int: SLGRIMVVVVTTTT
 *  TTTT: type (e.g. ), 0-15, also used for base color, also used for relative density (some particles fall through others)
 *  VVVV: random value, 0-10, used for RGB color variation
 *  R: Rigid,  true/false (1/0), affected by gravity?
 *  I: Inert,  true/false (1/0), does not interact with any particle in any special way? (may improve program performance)
 *  M: Moved,  true/false (1/0), did the particle move during this cycle? (particles only move once) 
 *  S: Solid,  true/false (1/0), is Solid? (is only displaced in L/R direction, by heavier particles (other solids))
 *  L: Liquid, true/false (1/0), is Liquid? (can be displaced in any direction, by heavier particles. can flow L/R through liquids/gases)
 *  G: Gas,    true/false (1/0), is Gas? (can be displaced in any direction, by heavier particles. can flow L/R through gases)
 *  [[ additional bits could be specified later to store more properties or data ]]
 *  
 *  Special materials:
 *  WALL: RIGID, INERT. (can always skip over these when processing world particles)
 *  INERT: AIR, STONE, SMOKE, WALL
 */

const TYPE_BITS = [0,1,2,3], RANDOM_BITS = [4,5,6,7],
      RIGID_BIT = 8, INERT_BIT = 9, MOVED_BIT = 10,
      SOLID_BIT = 11, LIQUID_BIT = 12, GAS_BIT = 13;

const SMOKE = 0,   AIR = 1,  FIRE = 2,   OIL = 3, WATER = 4, 
       LAVA = 5, PLANT = 6,  SAND = 7, STONE = 8, RIGID = 9;

// TODO: rename RIGID -> WALL. Later add WOOD (brown), FUNGI (pink), ICE (solid, light blue, FIRE+ICE = AIR+WATER, LAVA+ICE=STONE+WATER), ACID (light green, dissolves everything?)

var selectedType = SAND;

var colorArray = [];
colorArray[SMOKE] = [200, 200, 200, 255]; // white
colorArray[AIR]   = [ 20,  20,  20, 255]; // black
colorArray[FIRE]  = [235,  20,  20, 255]; // red
colorArray[OIL]   = [200,  20, 235, 255]; // purple
colorArray[WATER] = [ 20,  20, 235, 255]; // dark blue
colorArray[LAVA]  = [235, 128,  20, 255]; // orange
colorArray[PLANT] = [ 20, 200,  20, 255]; // dark green
colorArray[SAND]  = [235, 235,  20, 255]; // yellow
colorArray[STONE] = [150, 150, 150, 255]; // light gray
colorArray[RIGID] = [ 99,  99,  99, 255]; // dark gray

// for particle at position (x,y), change bit at index N to 1
function setBit( x,y, N ) { world[y][x] = world[y][x] | (1 << N); }

// for particle at position (x,y), change bit at index N to 0
function clearBit( x,y, N ) { world[y][x] = world[y][x] & (~(1 << N)); }

// for particle at position (x,y), get bit at index N
// since Javascript is "truthy", can interpret these as boolean values
function getBit( x,y, N ) { return (world[y][x] & (1 << N)) >> N; }

// check states
function isRigid( x,y )  { return getBit(x,y, RIGID_BIT); }
function isInert( x,y )  { return getBit(x,y, INERT_BIT); }
function isMoved( x,y )  { return getBit(x,y, MOVED_BIT); }
function isSolid( x,y )  { return getBit(x,y, SOLID_BIT); }
function isLiquid( x,y ) { return getBit(x,y, LIQUID_BIT); }
function isGas( x,y )    { return getBit(x,y, GAS_BIT); }

// set state to true
function setRigid( x,y )  { setBit(x,y, RIGID_BIT); }
function setInert( x,y )  { setBit(x,y, INERT_BIT); }
function setMoved( x,y )  { setBit(x,y, MOVED_BIT); }
function setSolid( x,y )  { setBit(x,y, SOLID_BIT); }
function setLiquid( x,y ) { setBit(x,y, LIQUID_BIT); }
function setGas( x,y )    { setBit(x,y, GAS_BIT); }

// set state to false
function clearMoved( x,y )  { clearBit(x,y, MOVED_BIT); }

// reset particle
function clearAll( x,y ) { world[y][x] = 0; }

// set random bits to a given value
function setRandom( x,y, r ) { world[y][x] = world[y][x] | (r << 4); }
function getRandom( x,y )    { return (world[y][x] & (0b1111 << 4)) >> 4; }

// set type bits to a given value
function setType( x,y, t ) { world[y][x] = world[y][x] | (t << 0); }
function getType( x,y )    { return world[y][x] & 0b1111; }

// set all particle properties based on type
function setParticleFromType( x,y, t )
{
    clearAll(x,y);
    setType(x,y, t);
    
    if (t != RIGID && t != AIR)
        setRandom( x,y, Math.floor(10 * Math.random()) );

    if ( t == SMOKE || t == AIR || t == FIRE )
        setGas(x,y);
    else if ( t == OIL || t == WATER || t == LAVA )
        setLiquid(x,y);
    else if ( t == PLANT || t == SAND || t == STONE || t == RIGID )
        setSolid(x,y);

    if (t == RIGID)
        setRigid(x,y);
    // TODO: INERT (much later)
    // MOVED is set during particle processing
}

function setParticleFromValue(x,y, v) { world[y][x] = v; }
function getParticle(x,y) { return world[y][x]; }

// check if coordinates are within world range
function isValid(x,y) { return (0 <= x) && (x < worldWidth) && (0 <= y) && (y < worldHeight); }

function couldMove(x,y) { return isValid(x,y) && !isMoved(x,y) && !isRigid(x,y); }

function initializeWorld()
{
    // remember! y-by-x = rows-by-columns = height-by-width
    // specification: 
    //  hundreds digit: 0 for not (yet) moved, 1 for moved
    //      tens digit: stores particle element type
    //      ones digit: random except for AIR and RIGID type
    world = [];
    for (let y = 0; y < worldHeight; y++)
        world.push( new Array(worldWidth).fill(0) );

    for (let y = 0; y < worldHeight; y++)
        for (let x = 0; x < worldWidth; x++)
            setParticleFromType(x,y, AIR);

    setParticleFromType(4,2, SAND);
    setParticleFromType(4,3, SAND);
    setParticleFromType(4,4, SAND);
    setParticleFromType(4,5, SAND);
    
    // use rigid layer at bottom to catch materials?
    for (let x = 0; x < worldWidth; x++)
        setParticleFromType(x, worldHeight-1, RIGID);

    setParticleFromType(0, worldHeight-2, RIGID);
    setParticleFromType(worldWidth-1, worldHeight-2, RIGID);    
}

// avoid unusual behaviors arising from left-to-right processing
//   by simulating x coordinates in a random order

var xCoord = [], yCoord = [];
for (let x = 0; x < worldWidth; x++)
    xCoord.push(x);
for (let y = 0; y < worldHeight; y++)
    yCoord.push(y);

function shuffleArray(array) 
{
    for (let i = array.length - 1; i >= 0; i--) 
    {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

// GPU-based rendering
var vertexShaderCode = `#version 300 es
in vec2 vertexPosition;
out vec2 UV;

void main() {
    UV = vertexPosition * 0.5 + 0.5;
    gl_Position = vec4(vertexPosition, 0.0, 1.0);
}
`;

var fragmentShaderCode = `#version 300 es
precision mediump float;
in vec2 UV;
uniform sampler2D u_texture;
out vec4 fragColor;

void main() 
{
    fragColor = texture(u_texture, UV);
}
`;

run();

// optional: user code
function initialize()
{
    currentTime = performance.now();
    previousTime = performance.now();

    initializeTexture();
    initializeWorld();
    convertWorldDataToPixelData();
    sendPixelDataToTexture();
}

// call after shader program initialized
function initializeTexture()
{
    // set up random texture
    texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);

    if (!pixelData)
        pixelData = new Uint8Array(textureWidth * textureHeight * 4);

    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureWidth, textureHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

    // program already compiled; set uniform data
    gl.useProgram(shaderProgram); // avoid a warning message
    const uTextureLocation = gl.getUniformLocation(shaderProgram, "u_texture");
    gl.uniform1i(uTextureLocation, 0); // only one texture, uses slot 0
}

function updateWorld()
{
    // indicate able to move 
    for (let y = 0; y < worldHeight; y++)
        for (let x = 0; x < worldWidth; x++)
            clearMoved(x,y);

    // use to randomize order in which particles are processed
    shuffleArray(xCoord);
    shuffleArray(yCoord);

    // note: bottom-up order is really important
    // move(swap) things that can move
    // TODO: figure out the "climbing" problem (eg continuously drop STONE on edge of SAND pile)
    //   partial solution below but requires limiting spawn to 1/2 pixel wide
    // TODO: water ripple across surface problem
    for (let y = worldHeight - 1; y >= 0; y--)
    {
        // y = yCoord[j]; // seems to look better but exacerbates "particles fall up" issue
        for (let i = 0; i < worldWidth; i++)
        {
            x = xCoord[i]; // makes a difference?

            // things that can't move or have already moved are skipped.
            if ( !couldMove(x,y) )
                continue;

            // air doesn't do anything -- but it pushes up SMOKE (lighter than air elements)
            //if ( getType(x,y) == AIR )
            //    continue;

            let s = 2 * Math.floor(2 * Math.random()) - 1; // is either +1 or -1
            if ( canSwapVert(x,y, x,y+1) )
                doSwap(x,y, 0,1);
            else if ( canSwapDiag(x,y, x-s,y+1) )
                doSwap(x,y, -s,1);
            else if ( canSwapDiag(x,y, x+s,y+1) )
                doSwap(x,y, +s,1);
            else if ( canSwapHoriz(x,y, x-s,y) )
                doSwap(x,y, -s,0);
            else if ( canSwapHoriz(x,y, x+s,y) )
                doSwap(x,y, +s,0);
        }       
    }
}

// reuse these variables to avoid constant reinitializing / garbage collection
var otherX = 0, otherY = 0, value = 0, offsetValue = 0, 
 particleType = 0, otherParticleType = 0;

function canSwapVert( px, py, qx, qy )
{
    // requires: this particle type is heavier/denser than the other particle directly below it
     /// AND the particle directly below is less dense than the ones on the diag below
     // (b/c if the diag areas are empty, they provide less resistance and the main particle would fall to the side instead)
     // TODO: AND don't let solids pass through other solids...
    return couldMove(qx,qy)
        && ( getType(px,py) > getType(qx,qy) )
        && ( getType(qx,qy) <= getType(qx+1,qy) )
        && ( getType(qx,qy) <= getType(qx-1,qy) );
}

function canSwapDiag( px, py, qx, qy )
{
    // requires: there is no particle to the side of this particle that would fall down
    // *and* this particle is heavier/denser than the other particle diagonally below it
    return couldMove(qx,qy)
        && !canSwapVert(qx,qy-1, qx,qy)
        && (getType(px,py) > getType(qx,qy));
}

function canSwapHoriz( px, py, qx, qy )
{
    // only liquids (non-solids) move horizontally, displacing only other liquids/gases
    return couldMove(qx,qy)
        && !isSolid(px,py)
        && (getType(px,py) > getType(qx,qy))
        && !canSwapVert(qx,qy-1, qx,qy);
}
    /*

    TODO: fails in last line when index out of bounds. (needs floor in simulation.) rethink.

    */


function doSwap( pointX, pointY, offsetX, offsetY )
{
    value = getParticle(pointX, pointY);
    setParticleFromValue(pointX, pointY, getParticle(pointX + offsetX, pointY + offsetY));
    setParticleFromValue(pointX + offsetX, pointY + offsetY, value);
0
    // AIR can move again, but nothing else can
    if ( getType(pointX, pointY) != AIR )
        setMoved(pointX, pointY);
    if ( getType(pointX + offsetX, pointY + offsetY) != AIR )
        setMoved(pointX + offsetX, pointY + offsetY);

    
}

function convertWorldDataToPixelData()
{
    i = 0;
    for (let y = worldHeight - 1; y >= 0; y--)
    {
        for (let x = 0; x < worldWidth; x++)
        {

            particleType = getType(x,y);

            offsetValue = 4 * (getRandom(x,y) - 5);
            pixelData[i + 0] = colorArray[ particleType ][0] + offsetValue; // Red
            pixelData[i + 1] = colorArray[ particleType ][1] + offsetValue; // Green
            pixelData[i + 2] = colorArray[ particleType ][2] + offsetValue; // Blue
            pixelData[i + 3] = colorArray[ particleType ][3]; // Alpha
            i += 4;
        }
        // console.log(i)
    }
}

function sendPixelDataToTexture()
{
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureWidth, textureHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixelData);
}

// optional: user code
function update()
{
    currentTime = performance.now();
    deltaTime = (currentTime - previousTime) / 1000.0;
    elapsedTime += deltaTime;
    previousTime = currentTime;
    tick++;
    
    fpsTimer += deltaTime;
    fpsTicker++;

    if (fpsTimer >= 1.0)
    {
        console.log("FPS: " + fpsTicker);
        fpsTimer = 0;
        fpsTicker = 0;
    }

    r = 2;
    // TODO: add a disk of particles, function of radius
    if (mouseDown)
        for (let dx = 0; dx < r; dx++)
            for (let dy = 0; dy < r; dy++)
                if ( distance(mousePixelX, mousePixelY, mousePixelX + dx, mousePixelY + dy ) <= r )
                    setParticleFromType( mousePixelX + dx, mousePixelY + dy, selectedType );

    updateWorld();
    convertWorldDataToPixelData();
    sendPixelDataToTexture();
}

function distance(x1,y1, x2,y2)
{
    return Math.sqrt( (y2-y1)*(y2-y1) + (x2-x1)*(x2-x1) );
}

// --------- //
// core code //
// --------- //

function run()
{
    // user defined initialization
    webGLsetup();
    initialize();
    loop();
}

function loop() 
{
    // call function on next screen refresh (typically approx 1/60 sec)
	// requestAnimationFrame( loop );
    // control update rate - can attain speed beyond refresh rate ?!
    setTimeout( loop, loopSpeed ); 
    // user defined updates
    update();
    render();
}

function render()
{
    // console.log("rendering...");
    
    gl.clear(gl.COLOR_BUFFER_BIT);

    gl.useProgram(shaderProgram);

    const drawOffset = 0;
    const vertexCount = 4;
    gl.drawArrays(gl.TRIANGLE_STRIP, drawOffset, vertexCount);
}

var mouseDown = false, mousePixelX = 0, mousePixelY = 0;
function onMouseDown(event)
{
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    mousePixelX = (x / (canvasWidth/worldWidth)) | 0;
    mousePixelY = (y / (canvasHeight/worldHeight)) | 0;
    mouseDown = true;    
}

function onMouseMove(event)
{
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    mousePixelX = (x / (canvasWidth/worldWidth)) | 0;
    mousePixelY = (y / (canvasHeight/worldHeight)) | 0;
}

function onMouseUp(event)
{
    mouseDown = false;
}

function onKeyDown(event)
{
    if (event.keyCode >= 48 && event.keyCode <= 57)
        selectedType = event.keyCode - 48;
}

function webGLsetup() 
{
    canvas = document.querySelector("#glcanvas");
    canvas.width = textureWidth;
    canvas.height = textureHeight;
    canvas.style = `width: ${canvasWidth}; height: ${canvasHeight}px; image-rendering: pixelated;`

    canvas.addEventListener("mousedown",  onMouseDown);
    canvas.addEventListener("mousemove",  onMouseMove);
    canvas.addEventListener("mouseup",    onMouseUp);
    canvas.addEventListener("mouseleave", onMouseUp);
    document.addEventListener("keydown", onKeyDown);
    
    gl = canvas.getContext("webgl2");

    if (gl == null) 
    {
        console.error( "Unable to initialize WebGL 2." );
        return;
    }

    gl.clearColor(0.0, 0.0, 0.0, 1.0);

    shaderProgram = initProgram(gl, vertexShaderCode, fragmentShaderCode);

    var vertexPositionLocation = gl.getAttribLocation(shaderProgram, "vertexPosition");

    const positions = [1.0, 1.0,   -1.0, 1.0,   1.0, -1.0,   -1.0, -1.0];
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    const numComponents = 2;
    const type = gl.FLOAT;
    const normalize = false;
    const stride = 0;
    const offset = 0;
    gl.vertexAttribPointer( vertexPositionLocation, numComponents, type, normalize, stride, offset );
    
    gl.enableVertexAttribArray( vertexPositionLocation );
}

function loadShader(gl, shaderType, source) 
{
    const shader = gl.createShader(shaderType);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);

    if ( !gl.getShaderParameter(shader, gl.COMPILE_STATUS) ) 
    {
        const message = "Shader Error: " + gl.getShaderInfoLog(shader);
        console.error(message);
        gl.deleteShader(shader);
        return null;
    }

    return shader;
}

function initProgram(gl, vsSource, fsSource)
{
    const vertexShader   = loadShader(gl, gl.VERTEX_SHADER, vsSource);
    const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);

    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);

    if ( !gl.getProgramParameter(program, gl.LINK_STATUS) ) 
    {
        const message = "Program Error: " + gl.getProgramInfoLog(program);
        console.error(message);
        gl.deleteProgram(program);
        return null;
    }

    return program;
}

</script>

</html>